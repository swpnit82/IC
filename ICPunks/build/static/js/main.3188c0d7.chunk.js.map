{"version":3,"sources":["utils/authClient.ts","../.dfx/local/canisters/icpunks/icpunks.did.js","../.dfx/local/canisters/icpunks/icpunks.js","utils/canister/actor.ts","utils/auth.tsx","utils/updateHead.ts","utils/canister.ts","utils/index.ts","components/TokenCard.tsx","views/Dashboard.tsx","AppRouter.tsx","components/Account.tsx","components/Header.tsx","index.tsx"],"names":["IDENTITY_URL","URLSearchParams","document","location","search","get","process","REACT_APP_INTERNET_IDENTITY_URL","authClient","constructor","ready","this","AuthClient","create","isAuthenticated","Promise","async","login","identityProvider","onSuccess","resolve","getIdentity","logout","returnTo","idlFactory","IDL","Service","Func","Nat","Bool","Vec","Opt","Principal","Text","isLocalEnv","DFX_NETWORK","host","dfxConfig","networks","local","bind","undefined","actorController","_actor","_isAuthenticated","initBaseActor","identity","agent","actor","HttpAgent","Actor","createActor","ICPunks_idl","canisterId","fetchRootKey","unauthenticateActor","authContext","createContext","ProvideAuth","children","auth","isAuthenticatedLocal","setIsAuthenticatedLocal","useState","_identity","_setIdentity","isAuthClientReady","setAuthClientReady","then","useEffect","all","getPrincipal","isAnonymous","authenticateActor","isAuthReady","logIn","console","error","logOut","localStorage","removeItem","KEY_LOCALSTORAGE_USER","useProvideAuth","authenticationClient","Provider","value","useAuth","useContext","APP_TITLE","updates","el","attrs","name","content","ICPunks","claimToken","tokenId","claim","BigInt","TokenCard","index","ownerText","setOwnerText","claimText","setClaimText","Button","variant","onClick","isWorking","setWorking","imgSrc","toString","Card","style","width","margin","Img","src","Body","Title","Dashboard","Component","tokens","listTokens","setState","render","state","Container","fluid","Row","map","Col","xl","lg","md","sm","AppRouter","exact","path","Account","principal","hex","Header","Navbar","bg","expand","Brand","href","Toggle","aria-controls","Collapse","id","Nav","className","Link","ICPunksApp","title","forEach","update","createElement","Object","entries","attr","head","appendChild","updateHead","ReactDOM","getElementById"],"mappings":"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","file":"static/js/main.3188c0d7.chunk.js","sourcesContent":["import { Identity } from '@dfinity/agent';\nimport { AuthClient } from '@dfinity/auth-client';\n\n// Where the IDP should be servied from\nconst IDENTITY_URL =\n  new URLSearchParams(document.location.search).get('internetIdentityUrl') ||\n  process.env.REACT_APP_INTERNET_IDENTITY_URL ||\n  'https://identity.ic0.app';\n\n/*\n * A simple wrapper for the official auth client to initialize it and wrap\n * some of the methods in promises\n */\nclass AuthClientWrapper {\n  public authClient?: AuthClient;\n  public ready = false;\n  constructor() {\n    return this;\n  }\n\n  // Create a new auth client and update it's ready state\n  async create() {\n    this.authClient = await AuthClient.create();\n    await this.authClient?.isAuthenticated();\n    this.ready = true;\n  }\n\n  async login(): Promise<Identity | undefined> {\n    return new Promise(async (resolve) => {\n      await this.authClient?.login({\n        identityProvider: IDENTITY_URL,\n        onSuccess: async () => {\n          resolve(this.authClient?.getIdentity());\n        },\n      });\n    });\n  }\n\n  async logout() {\n    return this.authClient?.logout({ returnTo: '/' });\n  }\n\n  async getIdentity() {\n    return this.authClient?.getIdentity();\n  }\n\n  async isAuthenticated() {\n    return this.authClient?.isAuthenticated();\n  }\n}\n\nexport const authClient = new AuthClientWrapper();\n","export default ({ IDL }) => {\n  const ICPunk = IDL.Service({\n    'claim' : IDL.Func([IDL.Nat], [IDL.Bool], []),\n    'countClaimedTokens' : IDL.Func([], [IDL.Nat], ['query']),\n    'listTokens' : IDL.Func([], [IDL.Vec(IDL.Opt(IDL.Principal))], ['query']),\n    'name' : IDL.Func([], [IDL.Text], ['query']),\n    'symbol' : IDL.Func([], [IDL.Text], ['query']),\n    'totalSupply' : IDL.Func([], [IDL.Nat], ['query']),\n    'transferFrom' : IDL.Func([IDL.Principal, IDL.Nat], [IDL.Bool], []),\n    'userTokens' : IDL.Func([IDL.Principal], [IDL.Vec(IDL.Nat)], ['query']),\n  });\n  return ICPunk;\n};\nexport const init = ({ IDL }) => { return []; };","import idlImport from './icpunks.did.js';\nexport const idlFactory = idlImport;\nexport const canisterId = \"rrkah-fqaaa-aaaaa-aaaaq-cai\";\n","import { Actor, HttpAgent, Identity } from \"@dfinity/agent\";\nimport {\n  idlFactory as ICPunks_idl,\n  canisterId as ICPunks_canister_id,\n} from \"dfx-generated/icpunks\";\n\n// import _SERVICE from \"./typings\";\nimport ICPunk from \"./icpunks\";\n\nimport dfxConfig from \"../../../dfx.json\";\n\nconst DFX_NETWORK = process.env.DFX_NETWORK || \"local\";\nconst isLocalEnv = DFX_NETWORK === \"local\";\n\nfunction getHost() {\n  // Setting host to undefined will default to the window location 👍🏻\n  return isLocalEnv ? dfxConfig.networks.local.bind : undefined;\n}\n\nconst host = getHost();\n\nfunction createActor(identity?: Identity) {\n  const agent = new HttpAgent({ host, identity });\n  const actor = Actor.createActor<ICPunk>(ICPunks_idl, {\n    agent,\n    canisterId: ICPunks_canister_id,\n  });\n  return { actor, agent };\n}\n\n/*\n * Responsible for keeping track of the actor, whether the user has logged\n * in again or not. A logged in user uses a different actor with their\n * Identity, to ensure their Principal is passed to the backend.\n */\nclass ActorController {\n  _actor: Promise<ICPunk>;\n  _isAuthenticated: boolean = false;\n\n  constructor() {\n    this._actor = this.initBaseActor();\n  }\n\n  async initBaseActor(identity?: Identity) {\n    const { agent, actor } = createActor(identity);\n    // The root key only has to be fetched for local development environments\n    if (isLocalEnv) {\n      await agent.fetchRootKey();\n    }\n    return actor;\n  }\n\n  /*\n   * Get the actor instance to run commands on the canister.\n   */\n  get actor() {\n    return this._actor;\n  }\n\n  /*\n   * Once a user has authenticated and has an identity pass this identity\n   * to create a new actor with it, so they pass their Principal to the backend.\n   */\n  async authenticateActor(identity: Identity) {\n    this._actor = this.initBaseActor(identity);\n    this._isAuthenticated = true;\n  }\n\n  /*\n   * If a user unauthenticates, recreate the actor without an identity.\n   */\n  unauthenticateActor() {\n    this._actor = this.initBaseActor();\n    this._isAuthenticated = false;\n  }\n}\n\nexport const actorController = new ActorController();\n","import React, { createContext, useContext, useEffect, useState } from \"react\";\nimport { authClient as authenticationClient } from \"./authClient\";\nimport {\n  // getUserFromCanister,\n  // getUserFromStorage,\n  KEY_LOCALSTORAGE_USER,\n} from \"./index\";\n\nimport { actorController } from \"./canister/actor\";\nimport { Identity } from \"@dfinity/agent\";\n// import { ProfileInfoPlus } from \"./canister/typings\";\n\nexport interface AuthContext {\n  isAuthenticated: boolean;\n  isAuthReady: boolean;\n  // hasCanCanAccount: boolean;\n  identity?: Identity;\n  logIn: () => void;\n  logOut: () => void;\n  // user: ProfileInfoPlus | undefined;\n  // setUser: (p: ProfileInfoPlus | undefined) => void;\n}\n\n// Provider hook that creates auth object and handles state\nexport function useProvideAuth(authClient): AuthContext {\n  // const [user, setUser] = useState<ProfileInfoPlus | undefined>();\n  const [isAuthenticatedLocal, setIsAuthenticatedLocal] = useState<boolean>(\n    false\n  );\n  const [_identity, _setIdentity] = useState<Identity | undefined>();\n  const [isAuthClientReady, setAuthClientReady] = useState(false);\n  // const [urlWithSearch] = useState<string>(globalThis.location.search);\n\n  // Creating the auth client is async and no auth related checks can happen\n  // until it's ready so we set a state variable to keep track of it\n  if (!authClient.ready) {\n    authClient.create().then(() => setAuthClientReady(true));\n  }\n\n  // // Use the user from local storage if it is set so the flow doesn't have to\n  // // make an async query.\n  // const setUserFromLocalStorage = () => {\n  //   const lsUser = getUserFromStorage(localStorage, KEY_LOCALSTORAGE_USER);\n  //   if (lsUser) {\n  //     setUser(lsUser);\n  //     setIsAuthenticatedLocal(true);\n  //     // Check to make sure your local storage user exists on the backend, and\n  //     // log out if it doesn't (this is when you have your user stored in local\n  //     // storage but the user was cleared from the backend)\n  //     getUserFromCanister(lsUser.userName).then((user_) => !user_ && logOut());\n  //     return () => void 0;\n  //   }\n  // };\n\n  // Once the auth client is initialized, get the identity and check that they\n  // are authenticated, then set them to be fully logged in.\n  useEffect(() => {\n    if (!authClient.ready) return;\n    Promise.all([authClient.getIdentity(), authClient.isAuthenticated()]).then(\n      ([identity, isAuthenticated]) => {\n        setIsAuthenticatedLocal(isAuthenticated || false);\n        _setIdentity(identity as Identity);\n        // if (isAuthenticated) {\n        //   setUserFromLocalStorage();\n        // }\n        setAuthClientReady(true); \n      }\n    );\n  }, [isAuthClientReady]);\n\n  // // For testing environments only, this bypasses the authentication with an\n  // // identity provider for testing purposes.\n  // const DFX_NETWORK = process.env.DFX_NETWORK || \"local\";\n  // useEffect(() => {\n  //   if (DFX_NETWORK === \"local\") {\n  //     const testUserParam = new URLSearchParams(urlWithSearch).get(\"testUser\");\n  //     if (testUserParam) {\n  //       setIsAuthenticatedLocal(true);\n  //       setAuthClientReady(true);\n  //       setUserFromLocalStorage();\n  //       if (!user) {\n  //         getUserFromCanister(testUserParam).then(\n  //           (user_) => !user && user_ && setUser(user_)\n  //         );\n  //       }\n  //     }\n  //   }\n  // }, [urlWithSearch, user]);\n\n  // // When user is set, and is not in local storage yet store the user object\n  // // from the canister in local storag so the user doesn't need to be fetched\n  // // every load. Then insure user is correctly logged in with identity service,\n  // // and set them to not logged in if not.\n  // useEffect(() => {\n  //   if (user && !getUserFromStorage(localStorage, KEY_LOCALSTORAGE_USER)) {\n  //     localStorage.setItem(\n  //       KEY_LOCALSTORAGE_USER,\n  //       JSON.stringify({ ...user, rewards: user.rewards }, (key, value) =>\n  //         typeof value === \"bigint\" ? value.toString() : value\n  //       )\n  //     );\n  //     if (!authClient.ready) return;\n  //     (async () => {\n  //       const identity = await authClient.getIdentity();\n  //       if (identity && !identity.getPrincipal().isAnonymous()) {\n  //         _setIdentity(identity);\n  //       }\n  //     })();\n  //   }\n  // }, [user]);\n\n  useEffect(() => {\n    if (_identity && !_identity.getPrincipal().isAnonymous()) {\n      // The auth client isn't ready to make requests until it's completed the\n      // async authenticate actor method.\n      setAuthClientReady(false);\n      actorController.authenticateActor(_identity).then(() => {\n        setAuthClientReady(true);\n      });\n    } else {\n      actorController.unauthenticateActor();\n    }\n  }, [_identity]);\n\n  // Just creating variables here so that it's pretty below\n  const identity = _identity;\n  const isAuthenticated = isAuthenticatedLocal;\n\n  // Login to the identity provider by sending user to Internet Identity\n  // and logging them in.\n  const logIn = async function (): Promise<void> {\n    if (!authClient) return;\n    await authClient.login();\n    const identity = await authClient.getIdentity();\n    if (identity) {\n      setIsAuthenticatedLocal(true);\n      _setIdentity(identity);\n    } else {\n      console.error(\"Could not get identity from internet identity\");\n    }\n  };\n\n  // Clears the authClient of any cached data, and redirects user to root.\n  function logOut() {\n    // setUser(undefined);\n    setIsAuthenticatedLocal(false);\n    localStorage.removeItem(KEY_LOCALSTORAGE_USER);\n    if (!authClient.ready) return;\n    authClient.logout();\n  }\n\n  return {\n    isAuthenticated,\n    isAuthReady: isAuthClientReady,\n    // hasCanCanAccount: user !== undefined,\n    logIn,\n    logOut,\n    // user,\n    identity,\n    // setUser,\n  };\n}\n\nconst authContext = createContext<AuthContext>(null!);\n\nexport function ProvideAuth({ children }) {\n  const auth = useProvideAuth(authenticationClient);\n  return <authContext.Provider value={auth}>{children}</authContext.Provider>;\n}\n\nexport const useAuth = () => {\n  return useContext(authContext);\n};\n","// Updated required for \"mobile web app\" behavior\n// https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html\n\nconst APP_TITLE = \"ICPunks\";\n\nconst updates = [\n  {\n    el: \"meta\",\n    attrs: { name: \"apple-mobile-web-app-title\", content: APP_TITLE },\n  },\n  {\n    el: \"meta\",\n    attrs: { name: \"apple-mobile-web-app-capable\", content: \"yes\" },\n  },\n  {\n    el: \"meta\",\n    attrs: {\n      name: \"apple-mobile-web-app-status-bar-style\",\n      content: \"black\",\n    },\n  },\n];\n\nexport const updateHead = (document: Document) => {\n  document.title = APP_TITLE;\n\n  updates.forEach(({ el, attrs }) => {\n    const update = document.createElement(el);\n    Object.entries(attrs).forEach(([attr, value]) => {\n      // @ts-ignore\n      update[attr] = value;\n    });\n    document.head.appendChild(update);\n  });\n};\n","/// <reference path=\"../react-app-env.d.ts\" />\n\n/*\n * This file wraps all of our canister interaction functions and makes sure they\n * return the expected values by massaging any data necessary.\n */\n\nimport { Principal } from \"@dfinity/agent\";\n\n\n// import { unwrap } from \"./index\";\nimport { actorController } from \"./canister/actor\";\n\nconst ICPunks = actorController;\n\nexport type Optional<Type> = [Type] | [];\n\nexport async function listTokens() : Promise<Principal[]> {\n  var actor = await ICPunks.actor;\n  var tokens = await actor.listTokens();\n\n  return tokens;\n}\n\nexport async function claimToken(tokenId: number) : Promise<boolean> {\n  var actor = await ICPunks.actor;\n  var result = await actor.claim(BigInt(tokenId));\n\n  return result;\n}\n\n// export function getUserFromStorage(\n//   storage = window.localStorage,\n//   key: string\n// ): ProfileInfoPlus | undefined {\n//   const lsUser = storage.getItem(key);\n//   if (lsUser) {\n//     return JSON.parse(lsUser, (k, v) => {\n//       if (k === \"rewards\") {\n//         return BigInt(v);\n//       }\n//       return v;\n//     }) as ProfileInfoPlus;\n//   } else {\n//     return undefined;\n//   }\n// }\n\n// export async function getUserNameByPrincipal(principal: Principal) {\n//   const icUserName = unwrap<string>(\n//     await (await CanCan.actor).getUserNameByPrincipal(principal)\n//   )!;\n//   return icUserName;\n// }\n\n// export async function createUser(\n//   userId: string,\n//   principal?: Principal | null\n// ): Promise<ProfileInfoPlus> {\n//   if (!principal) {\n//     throw Error(\"trying to create user without principal\");\n//   }\n//   const profile = unwrap<ProfileInfoPlus>(\n//     await (await CanCan.actor).createProfile(userId, [])\n//   );\n//   if (profile) {\n//     return profile;\n//   } else {\n//     throw Error(\"failed to create profile: \" + JSON.stringify(profile));\n//   }\n// }\n\n// export async function findOrCreateUser(\n//   userId: string,\n//   principal: Principal,\n//   key: string\n// ): Promise<ProfileInfoPlus> {\n//   const lsUSER = getUserFromStorage(undefined, key);\n//   if (lsUSER !== undefined) {\n//     return lsUSER;\n//   }\n\n//   const icUser = await getUserFromCanister(userId);\n//   if (icUser !== null) {\n//     return icUser;\n//   } else {\n//     try {\n//       createUser(userId, principal);\n//     } catch (error) {\n//       return Promise.reject(error);\n//     }\n//     throw Error(\"couldnt find or create user\");\n//   }\n// }\n\n// export async function isDropDay(): Promise<boolean> {\n//   return Boolean(unwrap<boolean>(await (await CanCan.actor).isDropDay()));\n// }\n\n// export async function getUserFromCanister(\n//   userId: string\n// ): Promise<ProfileInfoPlus | null> {\n//   const icUser = unwrap<ProfileInfoPlus>(\n//     await (await CanCan.actor).getProfilePlus([userId], userId)\n//   );\n//   if (icUser) {\n//     return icUser;\n//   } else {\n//     return null;\n//   }\n// }\n\n// export async function getSearchVideos(\n//   userId: string,\n//   terms: string[],\n//   limit: [] | [number] = [3]\n// ): Promise<VideoInfo[]> {\n//   // @ts-ignore\n//   const videos = unwrap<VideoResults>(\n//     await (await CanCan.actor).getSearchVideos(userId, terms, limit)\n//   );\n//   if (videos !== null) {\n//     const unwrappedVideos = videos.map((v) => v[0]);\n//     return unwrappedVideos;\n//   } else {\n//     return Promise.resolve([]);\n//   }\n// }\n\n// export async function getFeedVideos(userId: string): Promise<VideoInfo[]> {\n//   const videos = unwrap<VideoResults>(\n//     await (await CanCan.actor).getFeedVideos(userId, [])\n//   );\n//   if (videos !== null) {\n//     const unwrappedVideos = videos.map((v) => v[0]);\n//     return unwrappedVideos;\n//   } else {\n//     return Promise.resolve([]);\n//   }\n// }\n\n// export async function getVideoInfo(userId: string, videoId: string) {\n//   const videoInfo = unwrap(\n//     await (await CanCan.actor).getVideoInfo([userId], videoId)\n//   );\n//   if (videoInfo !== null) {\n//     return videoInfo;\n//   } else {\n//     throw Error(\"no video found with id: \" + videoId);\n//   }\n// }\n// export async function getProfilePic(userId: string) {\n//   const profilePic = unwrap(await (await CanCan.actor).getProfilePic(userId));\n//   return profilePic;\n// }\n\n// export async function createVideo(videoInit: VideoInit): Promise<string> {\n//   const videoId = unwrap<string>(\n//     await (await CanCan.actor).createVideo(videoInit)\n//   );\n//   if (videoId) {\n//     return videoId;\n//   } else {\n//     throw Error(\"failed to create video\");\n//   }\n// }\n\n// export async function follow(\n//   userToFollow: string,\n//   follower: string,\n//   willFollow: boolean\n// ) {\n//   try {\n//     await (await CanCan.actor).putProfileFollow(\n//       userToFollow,\n//       follower,\n//       willFollow\n//     );\n//   } catch (error) {\n//     console.error(error);\n//   }\n// }\n\n// export async function like(user: string, videoId: string, willLike: boolean) {\n//   try {\n//     await (await CanCan.actor).putProfileVideoLike(user, videoId, willLike);\n//   } catch (error) {\n//     console.error(error);\n//   }\n// }\n\n// export async function superLike(\n//   user: string,\n//   videoId: string,\n//   willSuperLike: boolean\n// ) {\n//   try {\n//     await (await CanCan.actor).putSuperLike(user, videoId, willSuperLike);\n//   } catch (error) {\n//     console.error(error);\n//   }\n// }\n\n// // Videos are stored as chunked byteArrays, and must be assembled once received\n// export async function getVideoChunks(videoInfo: VideoInfo): Promise<string> {\n//   const { videoId, chunkCount } = videoInfo;\n//   const chunkBuffers: Buffer[] = [];\n//   const chunksAsPromises: Array<Promise<Optional<number[]>>> = [];\n//   for (let i = 1; i <= Number(chunkCount.toString()); i++) {\n//     chunksAsPromises.push((await CanCan.actor).getVideoChunk(videoId, i));\n//   }\n//   const nestedBytes: number[][] = (await Promise.all(chunksAsPromises))\n//     .map(unwrap)\n//     .filter((v): v is number[] => v !== null);\n//   nestedBytes.forEach((bytes) => {\n//     const bytesAsBuffer = Buffer.from(new Uint8Array(bytes));\n//     chunkBuffers.push(bytesAsBuffer);\n//   });\n//   const videoBlob = new Blob([Buffer.concat(chunkBuffers)], {\n//     type: \"video/mp4\",\n//   });\n//   const vidURL = URL.createObjectURL(videoBlob);\n//   return vidURL;\n// }\n\n// export async function putVideoChunk(\n//   videoId: string,\n//   chunkNum: number,\n//   chunkData: number[]\n// ) {\n//   return (await CanCan.actor).putVideoChunk(videoId, chunkNum, chunkData);\n// }\n\n// export async function putVideoPic(videoId: string, file: number[]) {\n//   return (await CanCan.actor).putVideoPic(videoId, [file]);\n// }\n\n// export async function getVideoPic(videoId: string): Promise<number[]> {\n//   const icResponse = await (await CanCan.actor).getVideoPic(videoId);\n//   const pic = unwrap<number[]>(icResponse);\n//   if (pic !== null) {\n//     return pic;\n//   } else {\n//     throw Error(\"pic should not be empty\");\n//   }\n// }\n\n// export function getLocationCanisterPrincipal(location: Location): Principal {\n//   const pattern = /(\\.?((?:[a-z0-9]{5}-){4}[a-z0-9]{3})\\..*)|(canisterId=([^$&]+))/;\n//   const match = location.href.match(pattern);\n//   if (!match) {\n//     throw new Error(\"Failed to parse url containing canisterId\");\n//   }\n//   const [, , canisterId] = match;\n//   const canisterPrincipal = Principal.fromText(canisterId);\n//   return canisterPrincipal;\n// }\n\n// export async function checkUsername(username: string): Promise<boolean> {\n//   return await (await CanCan.actor).checkUsernameAvailable(username);\n// }\n\n// export async function getMessages(username: string): Promise<Message[]> {\n//   const messages = await (await CanCan.actor).getMessages(username);\n//   return messages;\n// }\n\n// export async function putRewardTransfer(\n//   sender: string,\n//   recipient: string,\n//   amount: BigInt\n// ) {\n//   return await (await CanCan.actor).putRewardTransfer(\n//     sender,\n//     recipient,\n//     amount\n//   );\n// }\n\n// export async function putAbuseFlagVideo(\n//   reporter: string,\n//   target: string,\n//   shouldFlag: boolean\n// ) {\n//   return await (await CanCan.actor).putAbuseFlagVideo(\n//     reporter,\n//     target,\n//     shouldFlag\n//   );\n// }\n","import { Principal } from \"@dfinity/agent\";\nimport { Optional } from \"./canister\";\n\nexport * from \"./CatchAll\";\nexport * from \"./auth\";\nexport * from \"./updateHead\";\nexport * from \"./canister\";\n\nexport const KEY_LOCALSTORAGE_USER = `ic-icpunks-user`;\n\nexport const MAX_CHUNK_SIZE = 1024 * 500; // 500kb\nexport const REWARDS_CHECK_INTERVAL = 60000;\nexport const hashtagRegExp = /(?:\\s|^)#[A-Za-z0-9\\-._]+(?:\\s|$)/gim;\n\nexport const encodeArrayBuffer = (file: ArrayBuffer): number[] =>\n  Array.from(new Uint8Array(file));\n\nexport function unwrap<T>(val: Optional<T>): T | null {\n  if (val[0] === undefined) {\n    return null;\n  } else {\n    return val[0];\n  }\n}\n\nexport function formatBigNumber(number: number): string {\n  if (number >= 1_000_000_000) {\n    return `${(number / 1_000_000_000).toFixed(2)}B`;\n  }\n  if (number >= 1_000_000) {\n    return `${(number / 1_000_000).toFixed(2)}M`;\n  }\n  if (number >= 1_000) {\n    return `${(number / 1_000).toFixed(1)}K`;\n  }\n  return `${number}`;\n}\n\n// Converts a file from a byteArray to a blob URL\n// TODO: Detect mime-type, \"fileToBlobUrl\" https://stackoverflow.com/a/29672957\nexport function fileToImgSrc(file: [] | number[][], imgType = \"jpeg\"): string {\n  const byteArray = new Uint8Array(file[0]);\n  const picBlob = new Blob([byteArray], { type: `image/${imgType}` });\n  const picSrc = URL.createObjectURL(picBlob);\n  return picSrc;\n}\n\n// Converts a word into a hex color for placeholder profile pic backgrounds\nexport function textToColor(text: string): string {\n  const numStringFromString = text\n    .split(\"\")\n    .map((char) => char.charCodeAt(0))\n    .join(\"\");\n  let hexFromNumString = parseInt(numStringFromString, 10).toString(16);\n  const hexLength = hexFromNumString.length;\n  const trimAmount = hexLength - 6;\n\n  if (trimAmount < 0) {\n    for (let i = 0; i < Math.abs(trimAmount); i++) {\n      hexFromNumString += \"0\";\n    }\n  }\n  if (trimAmount > 1) {\n    const startIndex = Math.ceil(trimAmount / 2);\n    const hexArray = hexFromNumString.split(\"\");\n    const trimmedArray = hexArray.slice(startIndex, startIndex + 6);\n\n    hexFromNumString = trimmedArray.join(\"\");\n  }\n\n  return `#${hexFromNumString}`;\n}\n\n// Regular expressions for detecting canisterId in various formats\nconst ic0AppHostRegEx = /(?:(?<canisterId>.*)\\.)?(?<subdomain>[^.]*)\\.(?<domain>ic0\\.app)$/;\nconst localhostRegEx = /(?<canisterId>(?:\\w{5}-){4}cai)\\.[^.]*$/;\n\n// Detect canisterId from current URL\nexport function getCanisterId(): Principal {\n  const loc = new URL(window.location.toString());\n  const hostName = loc.hostname;\n  const matchesIc0 = ic0AppHostRegEx.exec(hostName);\n  const matchesLocalhost = localhostRegEx.exec(hostName);\n\n  if (matchesIc0?.groups?.canisterId) {\n    return Principal.fromText(matchesIc0.groups.canisterId);\n  } else if (matchesLocalhost?.groups?.canisterId) {\n    return Principal.fromText(matchesLocalhost.groups.canisterId!);\n  } else if (loc.searchParams.get(\"canisterId\")) {\n    return Principal.fromText(loc.searchParams.get(\"canisterId\")!);\n  } else {\n    throw new Error(\"Could not find the canister ID.\");\n  }\n}\n","import { Principal } from \"@dfinity/agent\";\nimport { useEffect, useState } from \"react\";\nimport { Card, Button } from \"react-bootstrap\";\nimport { useAuth } from \"src/utils\";\n\nimport { claimToken } from \"../utils/canister\";\n\nexport default function TokenCard({ value, index }: { value: Principal, index: number }) {\n    const [ownerText, setOwnerText] = useState(\"\");\n    const [claimText, setClaimText] = useState(<Button variant=\"primary\" onClick={claimTokenButton}>Claim!</Button>);\n    const [isWorking, setWorking] = useState(false);\n    const authContext = useAuth();\n\n    let imgSrc = \"punks/cat\" + (index+1) + \".png\";\n\n    useEffect(() => {\n        if (value.toString() === \"\")\n            setOwnerText(\"Still ownerless, claim it!\");\n        else\n            setOwnerText(\"Already Claimed, sorry\");\n\n        if (authContext.isAuthenticated && authContext.identity?.getPrincipal().toString() === value.toString()) {\n            setOwnerText(\"Your token!\");\n            setClaimText(<></>);\n        }\n\n    }, [value, authContext.isAuthenticated]);\n\n    async function claimTokenButton() {\n        if (!authContext.isAuthenticated) return;\n        if (isWorking) return;\n\n        setWorking(true);\n\n        setClaimText(<>Claiming ...</>);\n        \n        var result = await claimToken(index);\n\n        if (result)\n            setClaimText(<>Claimed!</>);\n        else\n            setClaimText(<>Error during claiming</>);\n\n        setWorking(false);\n    }\n\n    return (\n        <Card style={{ width: '18rem', margin: '20px' }}>\n            <Card.Img variant=\"top\" src={imgSrc} />\n            <Card.Body>\n                <Card.Title>Punk {index}</Card.Title>\n                <Card.Text>\n                    {ownerText}\n                </Card.Text>\n                {claimText}\n            </Card.Body>\n        </Card>\n    );\n}","import { Principal } from \"@dfinity/agent\";\nimport { Component } from \"react\";\nimport { listTokens } from \"../utils/canister\";\nimport TokenCard from \"../components/TokenCard\";\n\nimport { Container, Col, Row } from \"react-bootstrap\";\ninterface DashboardProps {\n\n}\n\ninterface DashboardState {\n    tokens: Principal[];\n}\n\nexport class Dashboard extends Component<DashboardProps, DashboardState> {\n    async componentDidMount() {\n        var tokens = await listTokens();\n\n        this.setState({\n            tokens: tokens\n        });\n    }\n\n    render() {\n        if (this.state === null || this.state.tokens === null) {\n            return (<>Loading ...</>);\n        }\n\n        return (\n            <Container fluid>\n                <Row>\n                    {this.state.tokens.map((value, index) =>\n                        <Col key={index} xl=\"3\" lg=\"4\" md=\"6\" sm=\"12\">\n                            <TokenCard value={value} index={index} />\n                        </Col>\n                    )}</Row>\n            </Container>\n        );\n    }\n}","import React from \"react\";\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n} from \"react-router-dom\";\n// import { TransitionGroup, CSSTransition } from \"react-transition-group\";\n// import { SignIn } from \"./views/SignIn\";\n// import { SignUp } from \"./components/SignUp\";\n// import { useAuth } from \"./utils\";\n// import { PrivateRoutes } from \"./components/PrivateRoutes\";\n\nimport {Dashboard} from \"./views/Dashboard\";\n\n// function wrapRouteWithFade(Component) {\n//   return ({ match }) => (\n//     <CSSTransition\n//       in={match != null}\n//       timeout={300}\n//       classNames=\"page-fade\"\n//       unmountOnExit\n//     >\n//       <Component />\n//     </CSSTransition>\n//   );\n// }\n\nexport function AppRouter() {\n  // const { user, setUser, isAuthenticated, isAuthReady, logOut } = useAuth();\n\n  return (\n    <Router>\n       <Switch>\n         <Route exact path=\"/\">\n           <Dashboard/>\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n","import { useAuth } from \"src/utils\";\nimport { Button } from \"react-bootstrap\";\n\nexport default function Account() {\n    const authContext = useAuth();\n\n    async function signIn() {\n        authContext.logIn();\n    }\n\n    function signOut() {\n        authContext.logOut();\n    }\n\n    if (authContext.isAuthenticated) {\n        let principal = authContext.identity?.getPrincipal();\n        let hex = principal?.toString();\n\n        return (\n            <div>\n                <span>{hex}</span>\n        <Button variant=\"outline-success\" onClick={signOut}>Logout</Button>\n        </div>\n        );\n    }\n\n    return (<Button variant=\"outline-success\" onClick={signIn}>Login</Button>);\n}","import { Navbar, Nav } from \"react-bootstrap\";\nimport Account from \"./Account\";\n\nexport default function Header() {\n    return (\n        <Navbar bg=\"light\" expand=\"lg\">\n            <Navbar.Brand href=\"#home\">ICPunks</Navbar.Brand>\n            <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\n            <Navbar.Collapse id=\"basic-navbar-nav\">\n                <Nav className=\"mr-auto\">\n                    <Nav.Link href=\"/\">Punks</Nav.Link>\n                    <Nav.Link href=\"/about\">About</Nav.Link>\n                </Nav>\n                <Account/>\n            </Navbar.Collapse>\n        </Navbar>\n    );\n}","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { updateHead, ProvideAuth } from \"./utils\";\nimport { AppRouter } from \"./AppRouter\";\nimport Header from \"./components/Header\";\n// import \"./styles.scss\";\n\nfunction ICPunksApp() {\n  return (\n    <ProvideAuth>\n      <Header />\n      <AppRouter />\n    </ProvideAuth>\n  );\n}\n\n// Required for website to behave like a phone app on mobile devices\nupdateHead(document);\n\nReactDOM.render(<ICPunksApp />, document.getElementById(\"app\"));\n"],"sourceRoot":""}